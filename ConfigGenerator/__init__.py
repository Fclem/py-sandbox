from __future__ import print_function
try:
	import __generated as generated
except (SyntaxError, ImportError, Exception):
	generated = None
import os
from datetime import datetime

__path__ = os.path.realpath(__file__)
__dir_path__ = os.path.dirname(__path__)
__file_name__ = os.path.basename(__file__)

GENERATED_MODULE_NAME = '__generated'
GENERATED_FN = '%s.py' % GENERATED_MODULE_NAME
GENERATED_PATH = '%s/%s' % (__dir_path__, GENERATED_FN)

ONLY_EXT = ['py']
# EXCLUDE_FILES = ['__init__.py']
EXCLUDE_FILES = ['__init__.py', GENERATED_FN]
IGNORE_START_WITH = '__'


def nop():
	pass


def filter_function(file_name):
	verbose = False
	val = not file_name.startswith(IGNORE_START_WITH) and ('.' not in file_name or file_name.split('.')[-1] in ONLY_EXT)
	print('ignored %s' % file_name) if verbose and not val else nop()
	return val


class FilterableList(list):
	def filter_func(self, filt_func):
		assert callable(filt_func)
		return FilterableList(filter(filt_func, self))
	
	def filt_ext(self, filter_list=list()):
		# return FilterableList(
		#   filter(lambda w: not filter_list or ('.' in w and w.split('.')[-1] in filter_list), self)
		# )
		return FilterableList(filter(lambda w: not filter_list or ('.' in w and w.split('.')[-1] in filter_list), self))
	
	def exclude(self, filter_list=list()):
		# return FilterableList(filter(lambda w: not filter_list or w not in filter_list, self))
		return FilterableList(filter(lambda w: not (filter_list and w in filter_list), self))
	
	def starting_with(self, txt):
		return FilterableList(filter(lambda w: not txt or w.startswith(txt), self))
	
	def not_starting_with(self, txt=''):
		# return FilterableList(filter(lambda w: not txt or not w.statswith(txt), self))
		return FilterableList(filter(lambda w: not (txt and w.startswith(txt)), self))
	
	def ending_with(self, txt=''):
		return FilterableList(filter(lambda w: not txt or w.endswith(txt), self))
	
	def not_ending_with(self, txt=''):
		return FilterableList(filter(lambda w: not (txt and w.endswith(txt)), self))
	
	def __repr__(self):
		return '*%s' % str(super(FilterableList, self).__repr__())
	
	def __str__(self):
		return str(self.__repr__())
	

class WalkObject(object):
	path = ''
	dir_list = list
	file_list = FilterableList
	
	def __init__(self, walk_object):
		assert isinstance(walk_object, tuple) and len(walk_object) == 3
		self.path = walk_object[0]
		self.dir_list = walk_object[1]
		self.file_list = FilterableList(walk_object[2])
	
	def filter_files(self, filter_func):
		self.file_list = self.file_list.filter_func(filter_func)
	
	@property
	def data(self):
		return self.path, self.dir_list, self.file_list
	
	def __str__(self):
		return '<WO:%s>' % str(self.data)
	

def walker(a_path, filter_ext=list(), exclude=list(), recursive=False, verbose=False):
	"""
	
	:param a_path: str
	:type a_path: str
	:param filter_ext:
	:type filter_ext: list
	:param exclude:
	:type exclude: list
	:param recursive:
	:type recursive: boot
	:param verbose:
	:type verbose: boot
	:return:
	:rtype: list[WalkObject]
	"""
	if verbose:
		sup = '' if not filter_ext else ' with ext filter %s' % str(filter_ext)
		sup3 = '' if not exclude else ' with exclude %s' % str(exclude)
		sup2 = '' if not recursive else ' with recursion'
		print('walking dir %s%s%s%s' % (a_path, sup, sup3, sup2))
	walking = [i for i in os.walk(a_path)]
	result = list()
	walk_list = walking if recursive else filter(lambda w: w[0] == a_path, walking)
	print('walk_list: %s' % walk_list) if verbose else nop()
	for walk_item in [WalkObject(x) for x in walk_list]:
		print('walk_item: %s' % walk_item) if verbose else nop()
		# walk_item.file_list = walk_item.file_list.filt_ext(filter_ext).exclude(exclude).not_starting_with('__')
		walk_item.filter_files(filter_function)
		result.append(walk_item)
	return result


class ConfigGenerator(object):
	walker_list = list # type: list[WalkObject, ]
	class_name = ''
	
	def __init__(self, class_name, a_path=__dir_path__, filter_ext=list(), exclude=list(), verbose=False):
		global generated
		self.verbose = verbose
		self.class_name = class_name
		filter_ext = filter_ext or ONLY_EXT
		exclude = exclude or EXCLUDE_FILES
		self.walker_list = walker(a_path, filter_ext, exclude, verbose=verbose)
		print('generated? %s' % generated)
		if self.gen():
			self.reloader()
		print('generated? %s' % generated)

	def __str__(self):
		return str(self.walker_list)
	
	@staticmethod
	def reloader():
		global generated
		import importlib
		import time
		# time.sleep(2)
		# generated = importlib.import_module('ConfigGenerator.%s' % GENERATED_MODULE_NAME)
		generated = importlib.import_module(GENERATED_MODULE_NAME, package='.')
	
	def gen(self):
		with open(GENERATED_PATH, 'w') as a_file:
			sup = ''
			for each1 in self.walker_list:
				for each2 in each1.file_list:
					sup += "	@magic_const\n	def %s(): pass\n\n" % each2.replace('.py', '')
			a_file.write("""# Automatically generated by Breeze on %s
# Any change WILL BE OVERWRITTEN by Breeze
from utilz import magic_const, MagicAutoConstEnum


# Static object describing available Environments
# noinspection PyMethodParameters,PyPep8Naming
class %s(MagicAutoConstEnum):
%s
config_list = %s()
""" % (datetime.now().isoformat(), self.class_name, sup if sup else '	pass', self.class_name))
		return True
