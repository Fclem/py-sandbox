from __future__ import print_function
try:
	import __generated as generated
except (SyntaxError, ImportError, Exception):
	generated = None
import os
from datetime import datetime

__path__ = os.path.realpath(__file__)
__dir_path__ = os.path.dirname(__path__)
__file_name__ = os.path.basename(__file__)

GENERATED_MODULE_NAME = '__generated'
GENERATED_FN = '%s.py' % GENERATED_MODULE_NAME
GENERATED_PATH = '%s/%s' % (__dir_path__, GENERATED_FN)

ONLY_EXT = ['py']
EXCLUDE_FILES = ['__init__.py', GENERATED_FN]
IGNORE_START_WITH = '__'
MODULE_TEMPLATE = """# Automatically generated by Breeze on %s
# Any change WILL BE OVERWRITTEN by Breeze
from utilz import magic_const, MagicAutoConstEnum


# Static object describing available Environments
# noinspection PyMethodParameters,PyPep8Naming
class %s(MagicAutoConstEnum):
%s
config_list = %s()
"""
PROPERTY_TEMPLATE = "	@magic_const\n	def %s(): pass\n\n"


def nop():
	pass


def filter_function(file_name):
	verbose = False
	val = not file_name.startswith(IGNORE_START_WITH) and ('.' not in file_name or file_name.split('.')[-1] in ONLY_EXT)
	print('ignored %s' % file_name) if verbose and not val else nop()
	return val


class FilterableList(list):
	def filter_func(self, filt_func):
		assert callable(filt_func)
		return FilterableList(filter(filt_func, self))
	
	def __repr__(self):
		return '*%s' % str(super(FilterableList, self).__repr__())
	
	def __str__(self):
		return str(self.__repr__())
	

class WalkObject(object):
	path = ''
	dir_list = list
	file_list = FilterableList
	
	def __init__(self, walk_object):
		assert isinstance(walk_object, tuple) and len(walk_object) == 3
		self.path = walk_object[0]
		self.dir_list = walk_object[1]
		self.file_list = FilterableList(walk_object[2])
	
	def filter_files(self, filter_func):
		self.file_list = self.file_list.filter_func(filter_func)
	
	@property
	def data(self):
		return self.path, self.dir_list, self.file_list
	
	def __str__(self):
		return '<WO:%s>' % str(self.data)
	

def walker(a_path, filter_ext=list(), exclude=list(), recursive=False, verbose=False):
	"""
	
	:param a_path: str
	:type a_path: str
	:param filter_ext:
	:type filter_ext: list
	:param exclude:
	:type exclude: list
	:param recursive:
	:type recursive: boot
	:param verbose:
	:type verbose: boot
	:return:
	:rtype: list[WalkObject]
	"""
	if verbose:
		sup = '' if not filter_ext else ' with ext filter %s' % str(filter_ext)
		sup3 = '' if not exclude else ' with exclude %s' % str(exclude)
		sup2 = '' if not recursive else ' with recursion'
		print('walking dir %s%s%s%s' % (a_path, sup, sup3, sup2))
	walking = [i for i in os.walk(a_path)]
	result = list()
	walk_list = walking if recursive else filter(lambda w: w[0] == a_path, walking)
	print('walk_list: %s' % walk_list) if verbose else nop()
	for walk_item in [WalkObject(x) for x in walk_list]:
		print('walk_item: %s' % walk_item) if verbose else nop()
		walk_item.filter_files(filter_function)
		result.append(walk_item)
	return result


class ConfigGenerator(object):
	walker_list = list  # type: list[WalkObject, ]
	class_name = ''
	
	def __init__(self, class_name, a_path=__dir_path__, filter_ext=list(), exclude=list(), verbose=False):
		global generated
		self.verbose = verbose
		self.class_name = class_name
		filter_ext = filter_ext or ONLY_EXT
		exclude = exclude or EXCLUDE_FILES
		self.walker_list = walker(a_path, filter_ext, exclude, verbose=verbose)
	
	# self.gen()
	
	def __str__(self):
		return str(self.walker_list)
	
	@staticmethod
	def reloader():
		global generated
		import importlib
		generated = importlib.import_module(GENERATED_MODULE_NAME, package='.')
	
	def gen(self, do_reload=False):
		with open(GENERATED_PATH, 'w') as a_file:
			sup = ''
			for each1 in self.walker_list:
				for each2 in each1.file_list:
					sup += PROPERTY_TEMPLATE % each2.replace('.py', '')
			a_file.write(MODULE_TEMPLATE %
				(datetime.now().isoformat(), self.class_name, sup if sup else '	pass', self.class_name))
		if do_reload:
			print('generated? %s' % generated) if self.verbose else nop()
			self.reloader()
			print('generated? %s' % generated) if self.verbose else nop()
		return True
